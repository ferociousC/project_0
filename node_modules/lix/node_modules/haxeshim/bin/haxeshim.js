#!/usr/bin/env node

// Generated by Haxe 3.4.2 (git build development @ e033003)
if (typeof process !== "undefined") if (process.version < "v4.0.0") console.warn("Module " + (typeof(module) == "undefined" ? "" : module.filename) + " requires node.js version 4.0.0 or higher");

(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
Math.__name__ = true;
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.copy = function(o) {
	var o2 = { };
	var _g = 0;
	var _g1 = Reflect.fields(o);
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		o2[f] = Reflect.field(o,f);
	}
	return o2;
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return HxOverrides.substr(s,0,start.length) == start;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return HxOverrides.substr(s,slen - elen,elen) == end;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var Sys = function() { };
Sys.__name__ = true;
Sys.systemName = function() {
	var _g = process.platform;
	switch(_g) {
	case "darwin":
		return "Mac";
	case "freebsd":
		return "BSD";
	case "linux":
		return "Linux";
	case "win32":
		return "Windows";
	default:
		var other = _g;
		return other;
	}
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeString: function(s) {
		var b = haxe_io_Bytes.ofString(s);
		this.writeFullBytes(b,0,b.length);
	}
	,__class__: haxe_io_Output
};
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
_$Sys_FileOutput.__name__ = true;
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCharCode(c));
	}
	,writeBytes: function(s,pos,len) {
		return js_node_Fs.writeSync(this.fd,new js_node_buffer_Buffer(s.b.bufferValue),pos,len);
	}
	,writeString: function(s) {
		js_node_Fs.writeSync(this.fd,s);
	}
	,__class__: _$Sys_FileOutput
});
var haxe_StackItem = { __ename__ : true, __constructs__ : ["CFunction","Module","FilePos","Method","LocalFunction"] };
haxe_StackItem.CFunction = ["CFunction",0];
haxe_StackItem.CFunction.toString = $estr;
haxe_StackItem.CFunction.__enum__ = haxe_StackItem;
haxe_StackItem.Module = function(m) { var $x = ["Module",1,m]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.FilePos = function(s,file,line) { var $x = ["FilePos",2,s,file,line]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.Method = function(classname,method) { var $x = ["Method",3,classname,method]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.LocalFunction = function(v) { var $x = ["LocalFunction",4,v]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
haxe_IMap.prototype = {
	__class__: haxe_IMap
};
var haxe_Timer = function(time_ms) {
	var me = this;
	this.id = setInterval(function() {
		me.run();
	},time_ms);
};
haxe_Timer.__name__ = true;
haxe_Timer.delay = function(f,time_ms) {
	var t = new haxe_Timer(time_ms);
	t.run = function() {
		t.stop();
		f();
	};
	return t;
};
haxe_Timer.prototype = {
	stop: function() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	,run: function() {
	}
	,__class__: haxe_Timer
};
var haxe_ds_Option = { __ename__ : true, __constructs__ : ["Some","None"] };
haxe_ds_Option.Some = function(v) { var $x = ["Some",0,v]; $x.__enum__ = haxe_ds_Option; $x.toString = $estr; return $x; };
haxe_ds_Option.None = ["None",1];
haxe_ds_Option.None.toString = $estr;
haxe_ds_Option.None.__enum__ = haxe_ds_Option;
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	set: function(key,value) {
		if(__map_reserved[key] != null) {
			this.setReserved(key,value);
		} else {
			this.h[key] = value;
		}
	}
	,setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
	,__class__: haxe_ds_StringMap
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s) {
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	__class__: haxe_io_Bytes
};
var haxe_io_Eof = function() { };
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"] };
haxe_io_Error.Blocked = ["Blocked",0];
haxe_io_Error.Blocked.toString = $estr;
haxe_io_Error.Blocked.__enum__ = haxe_io_Error;
haxe_io_Error.Overflow = ["Overflow",1];
haxe_io_Error.Overflow.toString = $estr;
haxe_io_Error.Overflow.__enum__ = haxe_io_Error;
haxe_io_Error.OutsideBounds = ["OutsideBounds",2];
haxe_io_Error.OutsideBounds.toString = $estr;
haxe_io_Error.OutsideBounds.__enum__ = haxe_io_Error;
haxe_io_Error.Custom = function(e) { var $x = ["Custom",3,e]; $x.__enum__ = haxe_io_Error; $x.toString = $estr; return $x; };
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.join = function(paths) {
	var paths1 = paths.filter(function(s) {
		if(s != null) {
			return s != "";
		} else {
			return false;
		}
	});
	if(paths1.length == 0) {
		return "";
	}
	var path = paths1[0];
	var _g1 = 1;
	var _g = paths1.length;
	while(_g1 < _g) {
		var i = _g1++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths1[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var regex_r = new RegExp("([^:])/+","g".split("u").join(""));
	var result = tmp.replace(regex_r,"$1" + slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g11 = 0;
	var _g2 = tmp.length;
	while(_g11 < _g2) {
		var i = _g11++;
		var _g21 = tmp.charCodeAt(i);
		switch(_g21) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i1 = _g21;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCharCode(i1);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i2 = _g21;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCharCode(i2);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.isAbsolute = function(path) {
	if(StringTools.startsWith(path,"/")) {
		return true;
	}
	if(path.charAt(1) == ":") {
		return true;
	}
	if(StringTools.startsWith(path,"\\\\")) {
		return true;
	}
	return false;
};
haxe_io_Path.prototype = {
	__class__: haxe_io_Path
};
var haxeshim_ServerKind = { __ename__ : true, __constructs__ : ["Port","Stdio"] };
haxeshim_ServerKind.Port = function(num) { var $x = ["Port",0,num]; $x.__enum__ = haxeshim_ServerKind; $x.toString = $estr; return $x; };
haxeshim_ServerKind.Stdio = ["Stdio",1];
haxeshim_ServerKind.Stdio.toString = $estr;
haxeshim_ServerKind.Stdio.__enum__ = haxeshim_ServerKind;
var haxeshim_StdioState = { __ename__ : true, __constructs__ : ["AwaitingHeader","AwaitingData"] };
haxeshim_StdioState.AwaitingHeader = function(buf) { var $x = ["AwaitingHeader",0,buf]; $x.__enum__ = haxeshim_StdioState; $x.toString = $estr; return $x; };
haxeshim_StdioState.AwaitingData = function(buf,total) { var $x = ["AwaitingData",1,buf,total]; $x.__enum__ = haxeshim_StdioState; $x.toString = $estr; return $x; };
var haxeshim_CompilerServer = function(kind,scope,args) {
	this.freePort = tink_core__$Future_Future_$Impl_$.async(function(cb) {
		var test = js_node_Net.createServer();
		test.listen(0,function() {
			var port = test.address().port;
			test.close(function() {
				cb(tink_core_Outcome.Success(port));
			});
		});
	},true);
	this.args = args;
	this.scope = scope;
	switch(kind[1]) {
	case 0:
		var port1 = kind[2];
		this.waitOnPort(port1);
		break;
	case 1:
		this.stdio();
		break;
	}
};
haxeshim_CompilerServer.__name__ = true;
haxeshim_CompilerServer.prototype = {
	stdio: function() {
		var _gthis = this;
		js_node_Fs.watch(this.scope.configFile,{ persistent : false},function(_,_1) {
			_gthis.scope.reload();
		});
		var child = null;
		var quit = function() {
			if(child != null) {
				child.kill();
			}
		};
		process.on("exit",quit);
		var cleanExit = function() {
			process.exit();
		};
		process.on("SIGINT",cleanExit);
		process.on("SIGTERM",cleanExit);
		process.stdin.on("end",quit);
		process.stdin.on("close",quit);
		var state = haxeshim_StdioState.AwaitingHeader(new js_node_buffer_Buffer(0));
		var frame = function(payload) {
			var ret = new js_node_buffer_Buffer(4 + payload.length);
			ret.writeInt32LE(payload.length,0);
			payload.copy(ret,4);
			return ret;
		};
		var processData = function(data) {
			var postfix = new js_node_buffer_Buffer(0);
			var _g = data.indexOf(1);
			var ctx;
			if(_g == -1) {
				ctx = data;
			} else {
				var v = _g;
				postfix = data.slice(v);
				ctx = data.slice(0,v);
			}
			var ctx1 = _gthis.parseArgs(ctx);
			if(child == null || ctx1.version != _gthis.lastVersion) {
				if(child != null) {
					child.kill();
					child.stderr.unpipe(process.stderr);
				}
				_gthis.lastVersion = ctx1.version;
				var hx = _gthis.scope.haxeInstallation;
				child = js_node_ChildProcess.spawn(hx.compiler,_gthis.args.concat(["--wait","stdio"]),{ cwd : _gthis.scope.cwd, env : haxeshim__$Env_Env_$Impl_$.toVars(haxeshim_Exec.mergeEnv(hx.env())), stdio : "pipe"});
				var old = child;
				child.on("exit",function(code,_2) {
					if(child == old) {
						child = null;
					}
				});
				child.stderr.pipe(process.stderr);
			}
			var first = new js_node_buffer_Buffer(haxeshim_HaxeCli.checkClassPaths(_gthis.scope.resolve(ctx1.args)).join("\n"));
			var child1 = child.stdin;
			var processData1 = js_node_buffer_Buffer.concat([first,postfix]);
			child1.write(frame(processData1));
		};
		var reduce = function() {
			while(true) {
				var next;
				switch(state[1]) {
				case 0:
					var buf = state[2];
					if(buf.length >= 4) {
						next = haxeshim_StdioState.AwaitingData(buf.slice(4),buf.readInt32LE(0));
					} else {
						next = state;
					}
					break;
				case 1:
					var total = state[3];
					var buf1 = state[2];
					if(buf1.length >= total) {
						var next1 = buf1.slice(0,total);
						processData(next1);
						next = haxeshim_StdioState.AwaitingHeader(buf1.slice(total));
					} else {
						next = state;
					}
					break;
				default:
					next = state;
				}
				if(state == next) {
					break;
				}
				state = next;
			}
		};
		process.stdin.on("data",function(chunk) {
			switch(state[1]) {
			case 0:
				var buf2 = state[2];
				state = haxeshim_StdioState.AwaitingHeader(js_node_buffer_Buffer.concat([buf2,chunk]));
				break;
			case 1:
				var left = state[3];
				var buf3 = state[2];
				state = haxeshim_StdioState.AwaitingData(js_node_buffer_Buffer.concat([buf3,chunk]),left);
				break;
			}
			reduce();
		});
	}
	,parseArgs: function(raw) {
		var args = raw.toString().split("\n");
		var version;
		var _g = args.indexOf("--haxe-version");
		if(_g == -1) {
			if(this.lastVersion == null) {
				version = this.scope.haxeInstallation.version;
			} else {
				version = this.lastVersion;
			}
		} else {
			var v = _g;
			version = args.splice(v,2).pop();
		}
		return { version : version, args : args};
	}
	,waitOnPort: function(port) {
		var _gthis = this;
		var server = js_node_Net.createServer(function(cnx) {
			var buf = [];
			cnx.on("data",function(chunk) {
				var _g = chunk.indexOf(0);
				if(_g == -1) {
					buf.push(chunk);
				} else {
					var v = _g;
					var server1 = chunk.slice(0,v);
					buf.push(server1);
					var server2 = chunk.slice(v + 1);
					cnx.unshift(server2);
					var args = js_node_buffer_Buffer.concat(buf).toString().split("\n");
					buf = [];
					var version;
					var _g1 = args.indexOf("--haxe-version");
					if(_g1 == -1) {
						if(_gthis.lastVersion == null) {
							version = _gthis.scope.haxeInstallation.version;
						} else {
							version = _gthis.lastVersion;
						}
					} else {
						var v1 = _g1;
						version = args.splice(v1,2).pop();
					}
					_gthis.connect(version)(function(o) {
						switch(o[1]) {
						case 0:
							var compiler = o[2];
							compiler.write(args.join("\n") + String.fromCharCode(0));
							compiler.pipe(cnx,{ end : true});
							break;
						case 1:
							var e = o[2];
							cnx.end(e.message + "\n" + "\x02" + "\n","utf8");
							break;
						}
					});
				}
			});
			cnx.on("error",function() {
			});
			cnx.on("end",function() {
			});
		});
		server.listen(port);
	}
	,disconnect: function() {
		if(this.waiting == null) {
			return tink_core__$Future_Future_$Impl_$.sync(tink_core_Outcome.Success(tink_core_Noise.Noise));
		} else {
			return tink_core__$Promise_Promise_$Impl_$.next(this.waiting,function(w) {
				return tink_core__$Future_Future_$Impl_$.map(w.kill(),tink_core_Outcome.Success);
			});
		}
	}
	,connect: function(version) {
		var _gthis = this;
		if(version != this.lastVersion || this.waiting == null) {
			this.lastVersion = version;
			var nu = this.waiting = tink_core__$Promise_Promise_$Impl_$.next(this.disconnect(),function(_) {
				return tink_core__$Promise_Promise_$Impl_$.next(_gthis.freePort,tink_core__$Promise_Next_$Impl_$.ofSafeSync(function(port) {
					var installation = _gthis.scope.getInstallation(version);
					var proc = haxeshim_Exec.async(installation.compiler,_gthis.scope.cwd,_gthis.args.concat(["--wait",port == null ? "null" : "" + port]),installation.env());
					return { died : tink_core__$Future_Future_$Impl_$.async(function(cb) {
						var f = cb;
						var nu1 = function() {
							f(tink_core_Noise.Noise);
						};
						proc.on("exit",nu1);
						var f1 = cb;
						var nu2 = function() {
							f1(tink_core_Noise.Noise);
						};
						proc.on("error",nu2);
						var f2 = cb;
						var nu3 = function() {
							f2(tink_core_Noise.Noise);
						};
						proc.on("disconnect",nu3);
					}), version : version, socket : function() {
						return tink_core__$Future_Future_$Impl_$.async(function(cb1) {
							var max = 10;
							var connect = null;
							connect = function(attempt) {
								var cnx = js_node_Net.createConnection(port,"127.0.0.1");
								cnx.on("error",function(e) {
									if(attempt >= max) {
										var connect1 = tink_core_Outcome.Failure(new tink_core_TypedError(null,"Failed to connect to 127.0.0.1:" + port + " after " + max + " attempts because " + e,{ fileName : "CompilerServer.hx", lineNumber : 257, className : "haxeshim.CompilerServer", methodName : "connect"}));
										cb1(connect1);
									} else {
										var f3 = connect;
										var a1 = attempt + 1;
										haxe_Timer.delay(function() {
											f3(a1);
											return;
										},100);
									}
								}).on("connect",function() {
									cb1(tink_core_Outcome.Success(cnx));
								});
							};
							var connect2 = connect;
							connect2(1);
						});
					}, kill : function() {
						proc.kill();
						return tink_core__$Future_Future_$Impl_$.async(function(cb2) {
							var f4 = cb2;
							haxe_Timer.delay(function() {
								f4(tink_core_Noise.Noise);
							},500);
						});
					}};
				}));
			});
			this.waiting(function(o) {
				switch(o[1]) {
				case 0:
					var w = o[2];
					w.died(tink_core__$Callback_Callback_$Impl_$.fromNiladic(function() {
						if(_gthis.waiting == nu) {
							_gthis.waiting = null;
						}
					}));
					break;
				case 1:
					_gthis.waiting = null;
					break;
				}
			});
		}
		return tink_core__$Promise_Promise_$Impl_$.next(this.waiting,function(w1) {
			return w1.socket();
		});
	}
	,__class__: haxeshim_CompilerServer
};
var haxeshim__$Env_Env_$Impl_$ = {};
haxeshim__$Env_Env_$Impl_$.__name__ = true;
haxeshim__$Env_Env_$Impl_$.ofVars = function(vars) {
	var this1 = { };
	var ret = this1;
	var _g = 0;
	var _g1 = Reflect.fields(vars);
	while(_g < _g1.length) {
		var k = _g1[_g];
		++_g;
		ret[haxeshim_Os.IS_WINDOWS ? k.toUpperCase() : k] = vars[k];
	}
	var this2 = ret;
	return this2;
};
haxeshim__$Env_Env_$Impl_$.ofMap = function(map) {
	var this1 = { };
	var ret = this1;
	var k = map.keys();
	while(k.hasNext()) {
		var k1 = k.next();
		ret[haxeshim_Os.IS_WINDOWS ? k1.toUpperCase() : k1] = __map_reserved[k1] != null ? map.getReserved(k1) : map.h[k1];
	}
	var this2 = ret;
	return this2;
};
haxeshim__$Env_Env_$Impl_$.vars = function(this1) {
	return this1;
};
haxeshim__$Env_Env_$Impl_$.toVars = function(this1) {
	return Reflect.copy(this1);
};
haxeshim__$Env_Env_$Impl_$.get = function(this1,s) {
	return this1[haxeshim_Os.IS_WINDOWS ? s.toUpperCase() : s];
};
haxeshim__$Env_Env_$Impl_$.mergeInto = function(this1,that) {
	var _g = haxeshim__$Env_Env_$Impl_$.vars(that);
	if(this1 == null) {
		var v = _g;
		var this2 = v;
		return this2;
	} else if(_g == null) {
		var v1 = this1;
		var this3 = v1;
		return this3;
	} else {
		var a = this1;
		var b = _g;
		var this4 = { };
		var ret = this4;
		var _g1 = 0;
		var _g11 = [b,a];
		while(_g1 < _g11.length) {
			var vars = _g11[_g1];
			++_g1;
			var _g2 = 0;
			var _g3 = Reflect.fields(vars);
			while(_g2 < _g3.length) {
				var k = _g3[_g2];
				++_g2;
				ret[k] = vars[k];
			}
		}
		var this5 = ret;
		return this5;
	}
};
var haxeshim_Exec = function() { };
haxeshim_Exec.__name__ = true;
haxeshim_Exec.die = function(code,reason) {
	new _$Sys_FileOutput(2).writeString("" + reason + "\n");
	process.exit(code);
	throw new js__$Boot_HaxeError("unreachable");
};
haxeshim_Exec.gracefully = function(f) {
	try {
		return f();
	} catch( $e0 ) {
		if ($e0 instanceof js__$Boot_HaxeError) $e0 = $e0.val;
		if( js_Boot.__instanceof($e0,tink_core_TypedError) ) {
			var e = $e0;
			return haxeshim_Exec.die(e.code,e.message);
		} else {
		var e1 = $e0;
		return haxeshim_Exec.die(500,Std.string(e1));
		}
	}
};
haxeshim_Exec.mergeEnv = function(env) {
	return haxeshim__$Env_Env_$Impl_$.mergeInto(env,haxeshim__$Env_Env_$Impl_$.ofVars(process.env));
};
haxeshim_Exec.async = function(cmd,cwd,args,env) {
	return js_node_ChildProcess.spawn(cmd,args,{ cwd : cwd, stdio : "inherit", env : haxeshim__$Env_Env_$Impl_$.toVars(haxeshim_Exec.mergeEnv(env))});
};
haxeshim_Exec.shell = function(cmd,cwd,env) {
	try {
		return tink_core_Outcome.Success(js_node_ChildProcess.execSync(cmd,{ cwd : cwd, stdio : "inherit", env : haxeshim__$Env_Env_$Impl_$.toVars(haxeshim_Exec.mergeEnv(env))}));
	} catch( e ) {
		if (e instanceof js__$Boot_HaxeError) e = e.val;
		return tink_core_Outcome.Failure(new tink_core_TypedError(e.status,"Failed to invoke `" + cmd + "` because " + Std.string(e),{ fileName : "Exec.hx", lineNumber : 32, className : "haxeshim.Exec", methodName : "shell"}));
	}
};
haxeshim_Exec.sync = function(cmd,cwd,args,env) {
	var _g = js_node_ChildProcess.spawnSync(cmd,args,{ cwd : cwd, stdio : "inherit", env : haxeshim__$Env_Env_$Impl_$.toVars(haxeshim_Exec.mergeEnv(env))});
	var x = _g;
	if(x.error == null) {
		return tink_core_Outcome.Success(x.status);
	} else {
		var e = _g.error;
		return tink_core_Outcome.Failure(new tink_core_TypedError(null,"Failed to call " + cmd + " because " + Std.string(e),{ fileName : "Exec.hx", lineNumber : 39, className : "haxeshim.Exec", methodName : "sync"}));
	}
};
haxeshim_Exec["eval"] = function(cmd,cwd,args,env) {
	var _g = js_node_ChildProcess.spawnSync(cmd,args,{ cwd : cwd, env : haxeshim__$Env_Env_$Impl_$.toVars(haxeshim_Exec.mergeEnv(env))});
	var x = _g;
	if(x.error == null) {
		return tink_core_Outcome.Success({ status : x.status, stdout : x.stdout.toString(), stderr : x.stderr.toString()});
	} else {
		var e = _g.error;
		return tink_core_Outcome.Failure(new tink_core_TypedError(null,"Failed to call " + cmd + " because " + Std.string(e),{ fileName : "Exec.hx", lineNumber : 51, className : "haxeshim.Exec", methodName : "eval"}));
	}
};
var haxeshim_Fs = function() { };
haxeshim_Fs.__name__ = true;
haxeshim_Fs.findNearest = function(name,dir) {
	while(true) if(sys_FileSystem.exists("" + dir + "/" + name)) {
		return haxe_ds_Option.Some("" + dir + "/" + name);
	} else {
		var _g = haxe_io_Path.directory(dir);
		var same = _g;
		if(dir == same) {
			return haxe_ds_Option.None;
		} else {
			var parent = _g;
			dir = parent;
		}
	}
};
var haxeshim_HaxeCli = function(scope) {
	this.scope = scope;
};
haxeshim_HaxeCli.__name__ = true;
haxeshim_HaxeCli.main = function() {
	haxeshim_Neko.setEnv();
	new haxeshim_HaxeCli(haxeshim_Exec.gracefully(function() {
		return haxeshim_Scope.seek();
	})).dispatch(process.argv.slice(2));
};
haxeshim_HaxeCli.checkClassPaths = function(args) {
	var i = 0;
	var invalid = [];
	while(i < args.length) {
		var _g = args[i++];
		if(_g == "-cp") {
			var cp = args[i++];
			try {
				js_node_Fs.readdirSync(cp);
			} catch( e ) {
				invalid.push("classpath " + cp + " is not a directory or cannot be read from");
			}
		}
	}
	if(invalid.length != 0) {
		var v = invalid;
		haxeshim_Exec.die(404,invalid.join("\n"));
	}
	return args;
};
haxeshim_HaxeCli.prototype = {
	installLibs: function(silent) {
		var i = this.scope.getInstallationInstructions();
		var code = 0;
		var _g = i.missing;
		if(_g.length != 0) {
			var v = _g;
			code = 404;
			var _g1 = 0;
			while(_g1 < v.length) {
				var m = v[_g1];
				++_g1;
				new _$Sys_FileOutput(2).writeString("" + m.lib + " has no install instruction for missing classpath " + m.cp + "\n");
			}
		}
		var _g11 = 0;
		var _g2 = [i.instructions.install,i.instructions.postInstall];
		while(_g11 < _g2.length) {
			var cmds = _g2[_g11];
			++_g11;
			var _g3 = 0;
			while(_g3 < cmds.length) {
				var cmd = cmds[_g3];
				++_g3;
				if(!silent) {
					process.stdout.write(cmd == null ? "null" : "" + cmd);
					process.stdout.write("\n");
				}
				var _g4 = haxeshim_Exec.shell(cmd,process.cwd());
				if(_g4[1] == 1) {
					var e = _g4[2];
					code = e.code;
				}
			}
		}
		process.exit(code);
	}
	,dispatch: function(args) {
		var getScope = function() {
			return haxeshim_Exec.gracefully(function() {
				return haxeshim_Scope.seek({ cwd : null});
			});
		};
		var _hx_tmp;
		var _hx_tmp1;
		_hx_tmp = args.indexOf("--wait");
		var wait = _hx_tmp;
		if(wait >= 0 && wait < args.length - 1) {
			var tmp;
			var _g = args.splice(wait,2).pop();
			var _hx_tmp2;
			if(_g == null) {
				_hx_tmp2 = Std.parseInt(_g);
				var port = _hx_tmp2;
				tmp = haxeshim_ServerKind.Port(port);
			} else if(_g == "stdio") {
				tmp = haxeshim_ServerKind.Stdio;
			} else {
				_hx_tmp2 = Std.parseInt(_g);
				var port1 = _hx_tmp2;
				tmp = haxeshim_ServerKind.Port(port1);
			}
			new haxeshim_CompilerServer(tmp,haxeshim_Scope.seek(),args);
		} else {
			_hx_tmp1 = args.slice(0,2);
			if(_hx_tmp1.length == 2) {
				if(_hx_tmp1[0] == "--run") {
					var haxeShimExtension = _hx_tmp1[1];
					if(haxeShimExtension.indexOf("-") != -1 && haxeShimExtension.toLowerCase() == haxeShimExtension) {
						var args1 = args.slice(2);
						var scope = getScope();
						switch(haxeShimExtension) {
						case "install-libs":
							var tmp1;
							switch(args1.length) {
							case 0:
								tmp1 = false;
								break;
							case 1:
								if(args1[0] == "--silent") {
									tmp1 = true;
								} else {
									tmp1 = haxeshim_Exec.die(422,"unexpected arguments " + Std.string(args1));
								}
								break;
							default:
								tmp1 = haxeshim_Exec.die(422,"unexpected arguments " + Std.string(args1));
							}
							this.installLibs(tmp1);
							break;
						case "resolve-args":
							var f = $bind(scope,scope.resolve);
							var a1 = args1;
							var v = haxeshim_Exec.gracefully(function() {
								return f(a1);
							}).join("\n");
							process.stdout.write(Std.string(v));
							process.stdout.write("\n");
							process.exit(0);
							break;
						case "show-version":
							if(args1.length > 0) {
								haxeshim_Exec.die(422,"too many arguments");
							}
							var version;
							var _g1 = haxeshim_Exec["eval"](scope.haxeInstallation.compiler,scope.cwd,["-version"]);
							switch(_g1[1]) {
							case 0:
								var v1 = _g1[2];
								version = StringTools.trim(v1.stdout.toString() + v1.stderr.toString());
								break;
							case 1:
								var e = _g1[2];
								version = haxeshim_Exec.die(e.code,e.message);
								break;
							}
							process.stdout.write(Std.string("-D haxe-ver=" + version));
							process.stdout.write("\n");
							process.stdout.write(Std.string("-cp " + scope.haxeInstallation.stdLib));
							process.stdout.write("\n");
							break;
						default:
							var v2 = haxeShimExtension;
							haxeshim_Exec.die(404,"Unknown extension " + v2);
						}
					} else {
						var args2 = args;
						var scope1 = getScope();
						var _g2 = args2.indexOf("--haxe-version");
						var _g11 = args2.indexOf("--connect");
						if(_g11 == -1) {
							var tmp2 = _g2 == -1;
						} else if(_g2 == -1) {
							args2.push("--haxe-version");
							args2.push(scope1.haxeInstallation.version);
						}
						var _g21 = scope1.haxeInstallation.compiler;
						var haxe = _g21;
						if(sys_FileSystem.exists(haxe)) {
							var f1 = $bind(scope1,scope1.resolve);
							var a11 = args2;
							var _e = haxeshim_Exec.sync(haxe,scope1.cwd,haxeshim_HaxeCli.checkClassPaths(haxeshim_Exec.gracefully(function() {
								return f1(a11);
							})),scope1.haxeInstallation.env());
							process.exit(haxeshim_Exec.gracefully(function() {
								return tink_core_OutcomeTools.sure(_e);
							}));
						} else {
							var path = _g21;
							haxeshim_Exec.die(404,"haxe compiler not found at the expected location \"" + path + "\"");
						}
					}
				} else {
					var args3 = args;
					var scope2 = getScope();
					var _g3 = args3.indexOf("--haxe-version");
					var _g12 = args3.indexOf("--connect");
					if(_g12 == -1) {
						var tmp3 = _g3 == -1;
					} else if(_g3 == -1) {
						args3.push("--haxe-version");
						args3.push(scope2.haxeInstallation.version);
					}
					var _g22 = scope2.haxeInstallation.compiler;
					var haxe1 = _g22;
					if(sys_FileSystem.exists(haxe1)) {
						var f2 = $bind(scope2,scope2.resolve);
						var a12 = args3;
						var _e1 = haxeshim_Exec.sync(haxe1,scope2.cwd,haxeshim_HaxeCli.checkClassPaths(haxeshim_Exec.gracefully(function() {
							return f2(a12);
						})),scope2.haxeInstallation.env());
						process.exit(haxeshim_Exec.gracefully(function() {
							return tink_core_OutcomeTools.sure(_e1);
						}));
					} else {
						var path1 = _g22;
						haxeshim_Exec.die(404,"haxe compiler not found at the expected location \"" + path1 + "\"");
					}
				}
			} else {
				var args4 = args;
				var scope3 = getScope();
				var _g4 = args4.indexOf("--haxe-version");
				var _g13 = args4.indexOf("--connect");
				if(_g13 == -1) {
					var tmp4 = _g4 == -1;
				} else if(_g4 == -1) {
					args4.push("--haxe-version");
					args4.push(scope3.haxeInstallation.version);
				}
				var _g23 = scope3.haxeInstallation.compiler;
				var haxe2 = _g23;
				if(sys_FileSystem.exists(haxe2)) {
					var f3 = $bind(scope3,scope3.resolve);
					var a13 = args4;
					var _e2 = haxeshim_Exec.sync(haxe2,scope3.cwd,haxeshim_HaxeCli.checkClassPaths(haxeshim_Exec.gracefully(function() {
						return f3(a13);
					})),scope3.haxeInstallation.env());
					process.exit(haxeshim_Exec.gracefully(function() {
						return tink_core_OutcomeTools.sure(_e2);
					}));
				} else {
					var path2 = _g23;
					haxeshim_Exec.die(404,"haxe compiler not found at the expected location \"" + path2 + "\"");
				}
			}
		}
	}
	,__class__: haxeshim_HaxeCli
};
var haxeshim_Os = function() { };
haxeshim_Os.__name__ = true;
haxeshim_Os.slashes = function(path) {
	if(haxeshim_Os.IS_WINDOWS) {
		return StringTools.replace(path,"/","\\");
	} else {
		return path;
	}
};
var haxeshim_HaxeInstallation = function(path,version,haxelibRepo) {
	this.path = path;
	this.version = version;
	this.compiler = "" + path + "/haxe" + haxeshim_HaxeInstallation.EXT;
	this.haxelib = "" + path + "/haxelib" + haxeshim_HaxeInstallation.EXT;
	this.stdLib = "" + path + "/std";
	this.haxelibRepo = haxelibRepo;
};
haxeshim_HaxeInstallation.__name__ = true;
haxeshim_HaxeInstallation.prototype = {
	env: function() {
		var ret = haxeshim__$Env_Env_$Impl_$.ofVars({ HAXE_STD_PATH : this.stdLib, HAXEPATH : this.path, HAXELIB_PATH : this.haxelibRepo, HAXE_VERSION : this.version});
		return haxeshim__$Env_Env_$Impl_$.mergeInto(ret,haxeshim_Neko.ENV);
	}
	,__class__: haxeshim_HaxeInstallation
};
var haxeshim_Scope = function(haxeshimRoot,isGlobal,scopeDir,cwd) {
	this.haxeshimRoot = haxeshimRoot;
	this.isGlobal = isGlobal;
	this.scopeDir = scopeDir;
	this.scopeLibDir = "" + scopeDir + "/haxe_libraries";
	this.cwd = cwd;
	this.configFile = "" + scopeDir + "/" + haxeshim_Scope.CONFIG_FILE;
	this.versionDir = "" + haxeshimRoot + "/versions";
	this.haxelibRepo = "" + haxeshimRoot + "/haxelib";
	this.libCache = "" + haxeshimRoot + "/haxe_libraries";
	this.reload();
};
haxeshim_Scope.__name__ = true;
haxeshim_Scope.seek = function(options) {
	if(options == null) {
		options = { };
	}
	var cwd;
	var _g = options.cwd;
	if(_g == null) {
		cwd = process.cwd();
	} else {
		var v = _g;
		cwd = v;
	}
	var startLookingIn;
	var _g1 = options.startLookingIn;
	if(_g1 == null) {
		startLookingIn = cwd;
	} else {
		var v1 = _g1;
		startLookingIn = v1;
	}
	var haxeshimRoot;
	var _g2 = options.haxeshimRoot;
	if(_g2 == null) {
		haxeshimRoot = haxeshim_Scope.DEFAULT_ROOT;
	} else {
		var v2 = _g2;
		haxeshimRoot = v2;
	}
	var f = function(haxeshimRoot1,isGlobal,scopeDir,cwd1) {
		return new haxeshim_Scope(haxeshimRoot1,isGlobal,scopeDir,cwd1);
	};
	var a1 = haxeshimRoot;
	var a4 = cwd;
	var make = function(a2,a3) {
		return f(a1,a2,a3,a4);
	};
	var _g3 = haxeshim_Fs.findNearest(haxeshim_Scope.CONFIG_FILE,js_node_Path.resolve(startLookingIn));
	switch(_g3[1]) {
	case 0:
		var v3 = _g3[2];
		return make(false,haxe_io_Path.directory(v3));
	case 1:
		return make(true,haxeshimRoot);
	}
};
haxeshim_Scope.prototype = {
	reload: function() {
		var src;
		try {
			src = js_node_Fs.readFileSync(this.configFile,{ encoding : "utf8"});
		} catch( e ) {
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			if(this.isGlobal) {
				throw new js__$Boot_HaxeError("Global config file " + this.configFile + " does not exist or cannot be opened");
			} else {
				throw new js__$Boot_HaxeError("Unable to open file " + this.configFile + " because " + Std.string(e));
			}
		}
		var tmp;
		try {
			tmp = JSON.parse(src);
		} catch( e1 ) {
			if (e1 instanceof js__$Boot_HaxeError) e1 = e1.val;
			new _$Sys_FileOutput(2).writeString("Invalid JSON in file " + this.configFile + ":\n\n" + src + "\n\n");
			throw js__$Boot_HaxeError.wrap(e1);
		}
		this.config = tmp;
		if(this.config.version == null) {
			throw new js__$Boot_HaxeError("No version set in " + this.configFile);
		}
		if(this.config.resolveLibs == null) {
			this.config.resolveLibs = this.isGlobal ? "mixed" : "scoped";
		}
		var _g = this.config.resolveLibs;
		switch(_g) {
		case "haxelib":case "mixed":case "scoped":
			break;
		default:
			var v = _g;
			throw new js__$Boot_HaxeError("invalid value " + v + " for `resolveLibs` in " + this.configFile);
		}
		this.haxeInstallation = this.getInstallation(this.config.version);
		this.resolver = new haxeshim_Resolver(this.cwd,this.scopeLibDir,this.config.resolveLibs,$bind(this,this.getDefault));
	}
	,getDefault: function(variable) {
		switch(variable) {
		case "HAXESHIM_LIBCACHE":
			return this.libCache;
		case "SCOPE_DIR":
			return this.scopeDir;
		default:
			return null;
		}
	}
	,path: function(v) {
		if(haxe_io_Path.isAbsolute(v)) {
			return haxe_ds_Option.Some(v);
		} else if(StringTools.startsWith(v,"./") || StringTools.startsWith(v,"../")) {
			return haxe_ds_Option.Some("" + this.cwd + "/" + v);
		} else {
			return haxe_ds_Option.None;
		}
	}
	,getInstallation: function(version) {
		var _g = this.path(version);
		switch(_g[1]) {
		case 0:
			var path = _g[2];
			return new haxeshim_HaxeInstallation(path,version,this.haxelibRepo);
		case 1:
			return new haxeshim_HaxeInstallation("" + this.versionDir + "/" + version,version,this.haxelibRepo);
		}
	}
	,resolveThroughHaxelib: function(libs) {
		var _g = haxeshim_Exec["eval"](this.haxeInstallation.haxelib,this.cwd,["path"].concat(libs),this.haxeInstallation.env());
		switch(_g[1]) {
		case 0:
			if(_g[2].status == 0) {
				var stdout = _g[2].stdout;
				return haxeshim_Resolver.parseLines(stdout,function(cp) {
					return ["-cp",cp];
				});
			} else {
				var stdout1 = _g[2].stdout;
				var stderr = _g[2].stderr;
				var v = _g[2].status;
				new _$Sys_FileOutput(2).writeString(stdout1 + stderr);
				process.exit(v);
				return null;
			}
			break;
		case 1:
			var e = _g[2];
			return e.throwSelf();
		}
	}
	,interpolate: function(value) {
		return haxeshim_Resolver.interpolate(value,$bind(this,this.getDefault));
	}
	,parseDirectives: function(raw) {
		var ret = new haxe_ds_StringMap();
		var _g = 0;
		var _g1 = raw.split("\n").map(StringTools.trim);
		while(_g < _g1.length) {
			var line = _g1[_g];
			++_g;
			if(StringTools.startsWith(line,"#")) {
				var content = StringTools.ltrim(HxOverrides.substr(line,1,null));
				if(StringTools.startsWith(content,"@")) {
					var _g2 = content.indexOf(":");
					if(_g2 != -1) {
						var v = _g2;
						var name = content.substring(1,v);
						var tmp;
						var _g21 = __map_reserved[name] != null ? ret.getReserved(name) : ret.h[name];
						if(_g21 == null) {
							var v1 = [];
							if(__map_reserved[name] != null) {
								ret.setReserved(name,v1);
							} else {
								ret.h[name] = v1;
							}
							tmp = v1;
						} else {
							var v2 = _g21;
							tmp = v2;
						}
						tmp.push(StringTools.ltrim(HxOverrides.substr(content,v + 1,null)));
					}
				}
			}
		}
		return ret;
	}
	,getInstallationInstructions: function() {
		var missing = [];
		var instructions = { install : [], postInstall : []};
		var _g = 0;
		var _g1 = js_node_Fs.readdirSync(this.scopeLibDir);
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var path = "" + this.scopeLibDir + "/" + child;
			if(!js_node_Fs.statSync(path).isDirectory() && StringTools.endsWith(path,".hxml")) {
				var hxml = js_node_Fs.readFileSync(path,{ encoding : "utf8"});
				var args = haxeshim_Resolver.parseLines(hxml);
				var pos = 0;
				var max = args.length;
				while(pos < max) {
					var _g2 = args[pos++];
					if(_g2 == "-cp") {
						var cp = this.interpolate(args[pos++]);
						if(!sys_FileSystem.exists(cp)) {
							var dir = this.parseDirectives(hxml);
							var _g21 = __map_reserved["install"] != null ? dir.getReserved("install") : dir.h["install"];
							if(_g21 == null) {
								missing.push({ lib : child, cp : cp});
							} else if(_g21.length == 0) {
								missing.push({ lib : child, cp : cp});
							} else {
								var v = _g21;
								var _g22 = 0;
								while(_g22 < v.length) {
									var i = v[_g22];
									++_g22;
									instructions.install.push(i);
								}
								var _g23 = __map_reserved["post-install"] != null ? dir.getReserved("post-install") : dir.h["post-install"];
								if(_g23 != null) {
									var v1 = _g23;
									var _g24 = 0;
									while(_g24 < v1.length) {
										var i1 = v1[_g24];
										++_g24;
										instructions.postInstall.push(this.interpolate(i1));
									}
								}
							}
							pos = max;
						}
					}
				}
			}
		}
		return { missing : missing, instructions : instructions};
	}
	,resolve: function(args) {
		return this.resolver.resolve(args,$bind(this,this.resolveThroughHaxelib));
	}
	,__class__: haxeshim_Scope
};
var haxeshim_Neko = function() { };
haxeshim_Neko.__name__ = true;
haxeshim_Neko.setEnv = function() {
	if(haxeshim_Neko.isset) {
		if(haxeshim_Os.IS_WINDOWS) {
			var _g = 0;
			var this1 = haxeshim_Neko.ENV;
			var _g1 = this1 == null ? [] : Reflect.fields(this1);
			while(_g < _g1.length) {
				var k = _g1[_g];
				++_g;
				var v = haxeshim__$Env_Env_$Impl_$.get(haxeshim_Neko.ENV,k);
				process.env[k] = v;
			}
		}
		haxeshim_Neko.isset = false;
	}
};
var haxeshim_Resolver = function(cwd,libDir,mode,defaults) {
	this.cwd = haxe_io_Path.addTrailingSlash(haxe_io_Path.normalize(cwd));
	this.libDir = libDir;
	this.mode = mode;
	this.defaults = defaults;
};
haxeshim_Resolver.__name__ = true;
haxeshim_Resolver.interpolate = function(s,defaults) {
	if(s.indexOf("${") == -1) {
		return s;
	}
	var ret_b = "";
	var pos = 0;
	while(pos < s.length) {
		var _g = s.indexOf("${",pos);
		if(_g == -1) {
			ret_b += HxOverrides.substr(s,pos,null);
			break;
		} else {
			var v = _g;
			var len = v - pos;
			ret_b += len == null ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len);
			var start = v + 2;
			var end;
			var _g1 = s.indexOf("}",start);
			if(_g1 == -1) {
				throw new js__$Boot_HaxeError("unclosed interpolation in " + s);
			} else {
				var v1 = _g1;
				end = v1;
			}
			var name = HxOverrides.substr(s,start,end - start);
			var x;
			var _g11 = process.env[name];
			if(_g11 == null) {
				var _g12 = defaults(name);
				if(_g12 == null) {
					throw new js__$Boot_HaxeError("unknown variable " + name);
				} else {
					var v2 = _g12;
					x = v2;
				}
			} else if(_g11 == "") {
				var _g13 = defaults(name);
				if(_g13 == null) {
					throw new js__$Boot_HaxeError("unknown variable " + name);
				} else {
					var v3 = _g13;
					x = v3;
				}
			} else {
				var v4 = _g11;
				x = v4;
			}
			ret_b += Std.string(x);
			pos = end + 1;
		}
	}
	return ret_b;
};
haxeshim_Resolver.libHxml = function(libDir,libName) {
	return "" + libDir + "/" + libName + ".hxml";
};
haxeshim_Resolver.parseLines = function(source,normalize) {
	if(normalize == null) {
		normalize = function(x) {
			return [x];
		};
	}
	var ret = [];
	var _g = 0;
	var _g1 = source.split("\n").map(StringTools.trim);
	while(_g < _g1.length) {
		var line = _g1[_g];
		++_g;
		var _g2 = line.charAt(0);
		if(_g2 != null) {
			switch(_g2) {
			case "#":
				break;
			case "-":
				var _g21 = line.indexOf(" ");
				if(_g21 == -1) {
					ret.push(line);
				} else {
					var v = _g21;
					ret.push(HxOverrides.substr(line,0,v));
					ret.push(StringTools.trim(HxOverrides.substr(line,v,null)));
				}
				break;
			default:
				var _g22 = StringTools.trim(line);
				if(_g22 != "") {
					var v1 = _g22;
					var _g23 = 0;
					var _g3 = normalize(v1);
					while(_g23 < _g3.length) {
						var a = _g3[_g23];
						++_g23;
						ret.push(a);
					}
				}
			}
		}
	}
	return ret;
};
haxeshim_Resolver.prototype = {
	resolve: function(args,haxelib) {
		var _gthis = this;
		this.ret = [];
		this.errors = [];
		this.resolved = new haxe_ds_StringMap();
		this.process(args);
		var _g = this.errors;
		if(_g.length != 0) {
			var v = _g;
			throw new js__$Boot_HaxeError(v.map(function(e) {
				return e.message;
			}).join("\n"));
		}
		var start = 0;
		var pos = 0;
		var result = [];
		var libs = function(args1) {
			var ret = [];
			var libs1 = [];
			var i = 0;
			var max;
			var _g1 = args1.indexOf("--run");
			if(_g1 == -1) {
				max = args1.length;
			} else {
				var v1 = _g1;
				max = v1;
			}
			while(i < max) {
				var _g2 = args1[i++];
				if(_g2 == "-lib") {
					libs1.push(args1[i++]);
				} else {
					var v2 = _g2;
					ret.push(v2);
				}
			}
			ret = ret.concat(args1.slice(max));
			if(libs1.length == 0) {
				return ret;
			} else {
				return haxelib(libs1).concat(ret);
			}
		};
		var flush = function() {
			var result1 = _gthis.ret.slice(start,pos);
			var result2 = libs(result1);
			result = result.concat(result2);
			_gthis.resolved = new haxe_ds_StringMap();
			start = pos;
		};
		while(pos < this.ret.length) {
			pos += 1;
			var _g11 = this.ret[pos - 1];
			switch(_g11) {
			case "--each":case "--next":
				flush();
				break;
			default:
			}
		}
		flush();
		return ["--cwd",this.cwd].concat(result.map($bind(this,this.relative)));
	}
	,relative: function(path) {
		if(StringTools.startsWith(path,this.cwd)) {
			return haxe_io_Path.normalize(HxOverrides.substr(path,this.cwd.length,null));
		} else {
			return path;
		}
	}
	,resolveInScope: function(lib) {
		var _this = this.resolved;
		if(__map_reserved[lib] != null ? _this.getReserved(lib) : _this.h[lib]) {
			return tink_core_Outcome.Success(tink_core_Noise.Noise);
		} else {
			var _g = haxeshim_Resolver.libHxml(this.libDir,lib);
			var notFound = _g;
			if(!sys_FileSystem.exists(notFound)) {
				return tink_core_Outcome.Failure(new tink_core_TypedError(404,"Cannot resolve `-lib " + lib + "` because file " + notFound + " is missing",{ fileName : "Resolver.hx", lineNumber : 145, className : "haxeshim.Resolver", methodName : "resolveInScope"}));
			} else {
				var f = _g;
				this.resolved.set(lib,true);
				this.processHxml(f);
				return tink_core_Outcome.Success(tink_core_Noise.Noise);
			}
		}
	}
	,processHxml: function(file) {
		this.process(haxeshim_Resolver.parseLines(js_node_Fs.readFileSync(file,{ encoding : "utf8"})));
	}
	,process: function(args) {
		var _gthis = this;
		var i = 0;
		var max = args.length;
		var _g = [];
		var _g1 = 0;
		while(_g1 < args.length) {
			var a = args[_g1];
			++_g1;
			_g.push(haxeshim_Resolver.interpolate(a,this.defaults));
		}
		var args1 = _g;
		var next = function() {
			if(i >= max) {
				_gthis.errors.push(new tink_core_TypedError(null,"missing argument for " + args1[i - 1],{ fileName : "Resolver.hx", lineNumber : 194, className : "haxeshim.Resolver", methodName : "process"}));
				return "<MISSING>";
			} else {
				i += 1;
				return args1[i - 1];
			}
		};
		while(i < max) {
			i += 1;
			var _g11 = StringTools.trim(args1[i - 1]);
			switch(_g11) {
			case "":
				break;
			case "--cwd":
				this.cwd = haxe_io_Path.addTrailingSlash(this.absolute(next()));
				break;
			case "-cp":
				this.ret.push("-cp");
				this.ret.push(this.absolute(next()));
				break;
			case "-lib":
				var lib = [next()];
				var add = (function(lib1) {
					return function() {
						_gthis.ret.push("-lib");
						_gthis.ret.push(lib1[0]);
					};
				})(lib);
				var _g12 = this.mode;
				switch(_g12) {
				case "haxelib":
					add();
					break;
				case "mixed":
					if(lib[0].indexOf(":") != -1 || !tink_core_OutcomeTools.isSuccess(this.resolveInScope(lib[0]))) {
						add();
					}
					break;
				case "scoped":
					if(lib[0].indexOf(":") == -1) {
						var _g13 = this.resolveInScope(lib[0]);
						if(_g13[1] == 1) {
							var e = _g13[2];
							this.errors.push(e);
						}
					} else {
						throw new js__$Boot_HaxeError("Invalid `-lib " + lib[0] + "`. Version specification not supported in scoped mode");
					}
					break;
				}
				break;
			case "-resource":
				this.ret.push("-resource");
				var res = next();
				var tmp = this.ret;
				var _g14 = res.lastIndexOf("@");
				var tmp1;
				if(_g14 == -1) {
					tmp1 = res;
				} else {
					var v = _g14;
					tmp1 = HxOverrides.substr(res,0,v) + "@" + HxOverrides.substr(res,v + 1,null);
				}
				tmp.push(tmp1);
				break;
			case "-scoped-hxml":
				var target = this.absolute(next());
				var parts = haxeshim_Scope.seek({ cwd : haxe_io_Path.directory(target)}).resolve([target]);
				var _g15 = 0;
				while(_g15 < parts.length) {
					var arg = parts[_g15];
					++_g15;
					this.ret.push(arg);
				}
				break;
			default:
				var hxml = _g11;
				if(StringTools.endsWith(hxml,".hxml")) {
					this.processHxml(this.absolute(hxml));
				} else {
					var v1 = _g11;
					this.ret.push(v1);
				}
			}
		}
	}
	,absolute: function(path) {
		if(haxe_io_Path.isAbsolute(path)) {
			return haxe_io_Path.normalize(path);
		} else {
			return haxe_io_Path.join([this.cwd,path]);
		}
	}
	,__class__: haxeshim_Resolver
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_node_ChildProcess = require("child_process");
var js_node_Fs = require("fs");
var js_node_Net = require("net");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var sys_FileSystem = function() { };
sys_FileSystem.__name__ = true;
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _ ) {
		return false;
	}
};
var tink_core__$Callback_Callback_$Impl_$ = {};
tink_core__$Callback_Callback_$Impl_$.__name__ = true;
tink_core__$Callback_Callback_$Impl_$.fromNiladic = function(f) {
	var this1 = function(r) {
		f();
	};
	return this1;
};
tink_core__$Callback_Callback_$Impl_$.defer = function(f) {
	process.nextTick(f);
};
var tink_core__$Callback_CallbackList_$Impl_$ = {};
tink_core__$Callback_CallbackList_$Impl_$.__name__ = true;
tink_core__$Callback_CallbackList_$Impl_$.add = function(this1,cb) {
	var this2;
	var this3 = new Array(1);
	this2 = this3;
	var ret = this2;
	ret[0] = cb;
	var cell = ret;
	this1.push(cell);
	var this4 = function() {
		if(HxOverrides.remove(this1,cell)) {
			cell[0] = null;
		}
		cell = null;
	};
	return this4;
};
tink_core__$Callback_CallbackList_$Impl_$.invoke = function(this1,data) {
	var _g = 0;
	var _g1 = this1.slice();
	while(_g < _g1.length) {
		var cell = _g1[_g];
		++_g;
		if(cell[0] != null) {
			cell[0](data);
		}
	}
};
tink_core__$Callback_CallbackList_$Impl_$.clear = function(this1) {
	var _g = 0;
	var _g1 = this1.splice(0,this1.length);
	while(_g < _g1.length) {
		var cell = _g1[_g];
		++_g;
		cell[0] = null;
	}
};
var tink_core_TypedError = function(code,message,pos) {
	if(code == null) {
		code = 500;
	}
	this.code = code;
	this.message = message;
	this.pos = pos;
	this.exceptionStack = [];
	this.callStack = [];
};
tink_core_TypedError.__name__ = true;
tink_core_TypedError.withData = function(code,message,data,pos) {
	return tink_core_TypedError.typed(code,message,data,pos);
};
tink_core_TypedError.typed = function(code,message,data,pos) {
	var ret = new tink_core_TypedError(code,message,pos);
	ret.data = data;
	return ret;
};
tink_core_TypedError.catchExceptions = function(f,report,pos) {
	try {
		return tink_core_Outcome.Success(f());
	} catch( $e0 ) {
		if ($e0 instanceof js__$Boot_HaxeError) $e0 = $e0.val;
		if( js_Boot.__instanceof($e0,tink_core_TypedError) ) {
			var e = $e0;
			return tink_core_Outcome.Failure(e);
		} else {
		var e1 = $e0;
		return tink_core_Outcome.Failure(report == null ? tink_core_TypedError.withData(null,"Unexpected Error",e1,pos) : report(e1));
		}
	}
};
tink_core_TypedError.reporter = function(code,message,pos) {
	return function(e) {
		return tink_core_TypedError.withData(code,message,e,pos);
	};
};
tink_core_TypedError.rethrow = function(any) {
	throw js__$Boot_HaxeError.wrap(any);
};
tink_core_TypedError.prototype = {
	printPos: function() {
		return this.pos.className + "." + this.pos.methodName + ":" + this.pos.lineNumber;
	}
	,toString: function() {
		var ret = "Error#" + this.code + ": " + this.message;
		if(this.pos != null) {
			ret += " @ " + this.printPos();
		}
		return ret;
	}
	,throwSelf: function() {
		throw new js__$Boot_HaxeError(this);
	}
	,__class__: tink_core_TypedError
};
var tink_core__$Future_Future_$Impl_$ = {};
tink_core__$Future_Future_$Impl_$.__name__ = true;
tink_core__$Future_Future_$Impl_$._new = function(f) {
	var this1 = f;
	return this1;
};
tink_core__$Future_Future_$Impl_$.gather = function(this1) {
	var op = new tink_core_FutureTrigger();
	var self = this1;
	return tink_core__$Future_Future_$Impl_$._new(function(cb) {
		if(self != null) {
			this1($bind(op,op.trigger));
			self = null;
		}
		return op.future(cb);
	});
};
tink_core__$Future_Future_$Impl_$.map = function(this1,f,gather) {
	if(gather == null) {
		gather = true;
	}
	var ret = tink_core__$Future_Future_$Impl_$._new(function(callback) {
		return this1(function(result) {
			var data = f(result);
			callback(data);
		});
	});
	if(gather) {
		return tink_core__$Future_Future_$Impl_$.gather(ret);
	} else {
		return ret;
	}
};
tink_core__$Future_Future_$Impl_$.flatMap = function(this1,next,gather) {
	if(gather == null) {
		gather = true;
	}
	var ret = tink_core__$Future_Future_$Impl_$.flatten(tink_core__$Future_Future_$Impl_$.map(this1,next,gather));
	if(gather) {
		return tink_core__$Future_Future_$Impl_$.gather(ret);
	} else {
		return ret;
	}
};
tink_core__$Future_Future_$Impl_$.flatten = function(f) {
	return tink_core__$Future_Future_$Impl_$._new(function(callback) {
		var ret = null;
		ret = f(function(next) {
			ret = next(function(result) {
				callback(result);
			});
		});
		return ret;
	});
};
tink_core__$Future_Future_$Impl_$.lazy = function(l) {
	return tink_core__$Future_Future_$Impl_$._new(function(cb) {
		cb(l());
		return null;
	});
};
tink_core__$Future_Future_$Impl_$.sync = function(v) {
	return tink_core__$Future_Future_$Impl_$._new(function(callback) {
		callback(v);
		return null;
	});
};
tink_core__$Future_Future_$Impl_$.async = function(f,lazy) {
	if(lazy == null) {
		lazy = false;
	}
	if(lazy) {
		var f1 = f;
		return tink_core__$Future_Future_$Impl_$.flatten(tink_core__$Future_Future_$Impl_$.lazy(tink_core__$Lazy_Lazy_$Impl_$.ofFunc(function() {
			return tink_core__$Future_Future_$Impl_$.async(f1,false);
		})));
	} else {
		var op = new tink_core_FutureTrigger();
		f($bind(op,op.trigger));
		return op.future;
	}
};
tink_core__$Future_Future_$Impl_$._tryFailingFlatMap = function(f,map) {
	return tink_core__$Future_Future_$Impl_$.flatMap(f,function(o) {
		switch(o[1]) {
		case 0:
			var d = o[2];
			return map(d);
		case 1:
			var f1 = o[2];
			return tink_core__$Future_Future_$Impl_$.sync(tink_core_Outcome.Failure(f1));
		}
	});
};
var tink_core_FutureTrigger = function() {
	var _gthis = this;
	var this1 = [];
	this.list = this1;
	this.future = tink_core__$Future_Future_$Impl_$._new(function(callback) {
		if(_gthis.list == null) {
			callback(_gthis.result);
			return null;
		} else {
			return tink_core__$Callback_CallbackList_$Impl_$.add(_gthis.list,callback);
		}
	});
};
tink_core_FutureTrigger.__name__ = true;
tink_core_FutureTrigger.prototype = {
	trigger: function(result) {
		if(this.list == null) {
			return false;
		} else {
			var list = this.list;
			this.list = null;
			this.result = result;
			if(tink_core_FutureTrigger.depth >= 1000) {
				tink_core__$Callback_Callback_$Impl_$.defer(function() {
					tink_core_FutureTrigger.depth++;
					tink_core__$Callback_CallbackList_$Impl_$.invoke(list,result);
					tink_core__$Callback_CallbackList_$Impl_$.clear(list);
					tink_core_FutureTrigger.depth--;
				});
			} else {
				tink_core_FutureTrigger.depth++;
				tink_core__$Callback_CallbackList_$Impl_$.invoke(list,result);
				tink_core__$Callback_CallbackList_$Impl_$.clear(list);
				tink_core_FutureTrigger.depth--;
			}
			return true;
		}
	}
	,__class__: tink_core_FutureTrigger
};
var tink_core__$Lazy_Lazy_$Impl_$ = {};
tink_core__$Lazy_Lazy_$Impl_$.__name__ = true;
tink_core__$Lazy_Lazy_$Impl_$.ofFunc = function(f) {
	var result = null;
	var this1 = function() {
		if(f != null) {
			result = f();
			f = null;
		}
		return result;
	};
	return this1;
};
var tink_core_Noise = { __ename__ : true, __constructs__ : ["Noise"] };
tink_core_Noise.Noise = ["Noise",0];
tink_core_Noise.Noise.toString = $estr;
tink_core_Noise.Noise.__enum__ = tink_core_Noise;
var tink_core_Outcome = { __ename__ : true, __constructs__ : ["Success","Failure"] };
tink_core_Outcome.Success = function(data) { var $x = ["Success",0,data]; $x.__enum__ = tink_core_Outcome; $x.toString = $estr; return $x; };
tink_core_Outcome.Failure = function(failure) { var $x = ["Failure",1,failure]; $x.__enum__ = tink_core_Outcome; $x.toString = $estr; return $x; };
var tink_core_OutcomeTools = function() { };
tink_core_OutcomeTools.__name__ = true;
tink_core_OutcomeTools.sure = function(outcome) {
	switch(outcome[1]) {
	case 0:
		var data = outcome[2];
		return data;
	case 1:
		var failure = outcome[2];
		if(js_Boot.__instanceof(failure,tink_core_TypedError)) {
			return failure.throwSelf();
		} else {
			throw new js__$Boot_HaxeError(failure);
		}
		break;
	}
};
tink_core_OutcomeTools.isSuccess = function(outcome) {
	if(outcome[1] == 0) {
		return true;
	} else {
		return false;
	}
};
var tink_core__$Promise_Promise_$Impl_$ = {};
tink_core__$Promise_Promise_$Impl_$.__name__ = true;
tink_core__$Promise_Promise_$Impl_$.next = function(this1,f) {
	return tink_core__$Future_Future_$Impl_$._tryFailingFlatMap(this1,function(result) {
		return f(result);
	});
};
tink_core__$Promise_Promise_$Impl_$.ofOutcome = function(o) {
	return tink_core__$Future_Future_$Impl_$.sync(o);
};
var tink_core__$Promise_Next_$Impl_$ = {};
tink_core__$Promise_Next_$Impl_$.__name__ = true;
tink_core__$Promise_Next_$Impl_$.ofSafeSync = function(f) {
	return function(x) {
		return tink_core__$Promise_Promise_$Impl_$.ofOutcome(tink_core_Outcome.Success(f(x)));
	};
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { __name__ : ["Int"]};
var Dynamic = { __name__ : ["Dynamic"]};
var Float = Number;
Float.__name__ = ["Float"];
var Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = { __name__ : ["Class"]};
var Enum = { };
var __map_reserved = {}
haxeshim_Os.IS_WINDOWS = Sys.systemName() == "Windows";
haxeshim_Os.DELIMITER = haxeshim_Os.IS_WINDOWS ? ";" : ":";
haxeshim_HaxeInstallation.EXT = haxeshim_Os.IS_WINDOWS ? ".exe" : "";
haxeshim_Scope.CONFIG_FILE = ".haxerc";
haxeshim_Scope.DEFAULT_ROOT = (function($this) {
	var $r;
	var _g = process.env["HAXESHIM_ROOT"];
	$r = _g == null ? process.env[haxeshim_Os.IS_WINDOWS ? "APPDATA" : "HOME"] + "/haxe" : _g == "" ? process.env[haxeshim_Os.IS_WINDOWS ? "APPDATA" : "HOME"] + "/haxe" : (function($this) {
		var $r;
		var v = _g;
		$r = v;
		return $r;
	}($this));
	return $r;
}(this));
haxeshim_Neko.PATH = haxeshim_Os.slashes(haxeshim_Scope.DEFAULT_ROOT + "/neko");
haxeshim_Neko.isset = false;
haxeshim_Neko.ENV = (function($this) {
	var $r;
	var varName;
	var _g = Sys.systemName();
	switch(_g) {
	case "Mac":
		varName = "DYLD_LIBRARY_PATH";
		break;
	case "Windows":
		varName = "PATH";
		break;
	default:
		varName = "LD_LIBRARY_PATH";
	}
	var _g1 = process.env[varName];
	$r = _g1 == null ? (function($this) {
		var $r;
		var _g11 = new haxe_ds_StringMap();
		{
			var value = haxeshim_Neko.PATH;
			if(__map_reserved[varName] != null) {
				_g11.setReserved(varName,value);
			} else {
				_g11.h[varName] = value;
			}
		}
		$r = haxeshim__$Env_Env_$Impl_$.ofMap(_g11);
		return $r;
	}($this)) : (function($this) {
		var $r;
		var withNeko = _g1;
		$r = withNeko.indexOf(haxeshim_Neko.PATH) != -1 ? haxeshim__$Env_Env_$Impl_$.ofVars({ }) : (function($this) {
			var $r;
			var v = _g1;
			var _g12 = new haxe_ds_StringMap();
			{
				var value1 = v + haxeshim_Os.DELIMITER + haxeshim_Neko.PATH;
				if(__map_reserved[varName] != null) {
					_g12.setReserved(varName,value1);
				} else {
					_g12.h[varName] = value1;
				}
			}
			$r = haxeshim__$Env_Env_$Impl_$.ofMap(_g12);
			return $r;
		}($this));
		return $r;
	}($this));
	return $r;
}(this));
js_Boot.__toStr = ({ }).toString;
tink_core_FutureTrigger.depth = 0;
haxeshim_HaxeCli.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
